name: 🔒 Seal the Capsule

on:
  pull_request:
    types: [opened]
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  seal-message:
    runs-on: ubuntu-latest
    
    steps:
      - name: 🔍 Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: 📝 Extract username
        id: extract
        run: |
          USERNAME="${{ github.event.pull_request.user.login }}"
          echo "username=$USERNAME" >> $GITHUB_OUTPUT
          echo "📋 Processing message from: @$USERNAME"

      - name: "🔒 Security: Validate PR changes"
        id: validate
        run: |
          echo "🔍 Checking what files were changed..."
          
          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Count changes outside messages/ folder
          DANGEROUS_CHANGES=$(echo "$CHANGED_FILES" | grep -v "^messages/" | grep -v "^$" || true)

          if [ ! -z "$DANGEROUS_CHANGES" ]; then
            echo "❌ SECURITY: PR attempts to modify files outside messages/ folder!"
            echo "Blocked files:"
            echo "$DANGEROUS_CHANGES"
            echo ""
            echo "⚠️ Only files in messages/ folder are allowed."
            exit 1
          fi

          echo "✅ Security check passed - only messages/ folder modified"

      - name: "⏰ Limit submissions (1 per 24 hours)"
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          REPO_OWNER="${{ github.repository_owner }}"
          
          # Allow repository owner to bypass rate limiting (for testing)
          if [ "$USERNAME" = "$REPO_OWNER" ]; then
            echo "✅ Repository owner ($USERNAME) - rate limit bypassed for testing"
            exit 0
          fi
          
          # Check if user has submitted in the last 24 hours
          if [ -d "sealed/${USERNAME}" ]; then
            LATEST_FILE=$(ls -t sealed/${USERNAME}/*.gpg 2>/dev/null | head -1)
            if [ ! -z "$LATEST_FILE" ]; then
              # Get file timestamp (seconds since epoch)
              FILE_TIME=$(stat -c %Y "$LATEST_FILE" 2>/dev/null || stat -f %m "$LATEST_FILE" 2>/dev/null)
              CURRENT_TIME=$(date +%s)
              TIME_DIFF=$((CURRENT_TIME - FILE_TIME))
              HOURS_DIFF=$((TIME_DIFF / 3600))
              
              echo "⏰ Last submission: $HOURS_DIFF hours ago"
              
              if [ $TIME_DIFF -lt 86400 ]; then
                HOURS_REMAINING=$((24 - HOURS_DIFF))
                echo "❌ Rate limit: You submitted a message $HOURS_DIFF hours ago."
                echo "⏰ Please wait $HOURS_REMAINING more hours before submitting again."
                echo "💡 You can submit once every 24 hours."
                exit 1
              fi
            fi
          fi
          
          echo "✅ Rate limit check passed - submission allowed"

      - name: ✅ Validate message file
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          MESSAGE_FILE="messages/${USERNAME}.txt"
          
          if [ ! -f "$MESSAGE_FILE" ]; then
            echo "❌ Error: $MESSAGE_FILE not found"
            echo "Please create a file named exactly: messages/${USERNAME}.txt"
            exit 1
          fi
          
          # Check if file is not empty
          if [ ! -s "$MESSAGE_FILE" ]; then
            echo "❌ Error: $MESSAGE_FILE is empty"
            exit 1
          fi
          
          echo "✅ Message file found: $MESSAGE_FILE"
          echo "📏 Message size: $(wc -c < "$MESSAGE_FILE") bytes"

      - name: 🔐 Setup GPG
        run: |
          echo "📦 Installing GPG..."
          sudo apt-get update
          sudo apt-get install -y gnupg
          gpg --version

      - name: 🔑 Import GPG public key
        env:
          GPG_PUBLIC_KEY: ${{ secrets.GPG_PUBLIC_KEY }}
        run: |
          if [ -z "$GPG_PUBLIC_KEY" ]; then
            echo "❌ Error: GPG_PUBLIC_KEY secret not configured!"
            echo "Please add GPG_PUBLIC_KEY to repository secrets."
            exit 1
          fi
          
          echo "🔑 Importing GPG public key..."
          echo "$GPG_PUBLIC_KEY" | gpg --import
          
          echo "📋 Listing imported keys:"
          gpg --list-keys

      - name: 🔒 Encrypt message
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          MESSAGE_FILE="messages/${USERNAME}.txt"
          
          # Create sealed directory structure
          mkdir -p "sealed/${USERNAME}"
          
          # Generate unique filename with timestamp
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          ENCRYPTED_FILE="sealed/${USERNAME}/${USERNAME}-${TIMESTAMP}.gpg"
          
          echo "🔐 Encrypting message..."
          echo "📄 Input: $MESSAGE_FILE"
          echo "🔒 Output: $ENCRYPTED_FILE"
          
          # Encrypt the message
          gpg --encrypt \
              --recipient "time-capsule-2035" \
              --armor \
              --trust-model always \
              --output "$ENCRYPTED_FILE" \
              "$MESSAGE_FILE"
          
          if [ ! -f "$ENCRYPTED_FILE" ]; then
            echo "❌ Encryption failed!"
            exit 1
          fi
          
          echo "✅ Message encrypted successfully!"
          echo "📊 Encrypted file size: $(wc -c < "$ENCRYPTED_FILE") bytes"
          ls -lh "$ENCRYPTED_FILE"
          
          # Save filename for later steps
          echo "encrypted_file=$ENCRYPTED_FILE" >> $GITHUB_ENV

      - name: 💾 Save encrypted file temporarily
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          
          # Copy entire sealed folder to /tmp to preserve across checkout
          cp -r sealed /tmp/sealed-backup
          echo "✅ Saved encrypted files to /tmp/sealed-backup"

      - name: 🔄 Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: 📦 Restore encrypted files
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          
          # Ensure sealed directory exists in main
          mkdir -p sealed
          
          # Restore the encrypted files
          if [ -d "/tmp/sealed-backup/${USERNAME}" ]; then
            mkdir -p "sealed/${USERNAME}"
            cp -r /tmp/sealed-backup/${USERNAME}/* "sealed/${USERNAME}/"
            echo "✅ Restored encrypted files to sealed/${USERNAME}/"
            ls -lh "sealed/${USERNAME}/"
          else
            echo "❌ Failed to restore encrypted files!"
            exit 1
          fi

      - name: ✍️ Commit encrypted message to main
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          
          # Configure Git
          git config user.name "Time Capsule Bot"
          git config user.email "bot@github-time-capsule.local"
          
          # Add encrypted files
          git add sealed/${USERNAME}/
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "⚠️ No changes to commit"
          else
            git commit -m "🔒 Sealed message from @${USERNAME}" \
                       -m "Message encrypted and sealed until January 1, 2035." \
                       -m "" \
                       -m "- Encrypted with GPG (AES-256)" \
                       -m "- Stored in: sealed/${USERNAME}/" \
                       -m "- Will be automatically decrypted on Jan 1, 2035"
            
            echo "📤 Pushing to main branch..."
            git push origin main
            echo "✅ Successfully committed and pushed encrypted message!"
          fi

      - name: 🎉 Comment on PR with success message
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const username = '${{ steps.extract.outputs.username }}';
            const comment = [
              '## 🎉 Your Message Has Been Sealed!',
              '',
              `**@${username}**, your time capsule message has been successfully encrypted and sealed!`,
              '',
              '### ✅ What Just Happened:',
              '- ✅ Your message was encrypted with **AES-256-GCM** encryption',
              `- ✅ Saved to: \`sealed/${username}/\``,
              '- ✅ Committed to the main branch',
              '- ✅ This PR will be closed automatically',
              '',
              '### 🔒 What Happens Next:',
              '- 🔐 Your message is now **locked until January 1, 2035**',
              '- ⏰ On that date, it will be **automatically decrypted**',
              '- 🎉 You and everyone else can read it then!',
              '',
              '### 📌 Important Notes:',
              '- 💾 Keep a copy of your original message in your fork if you want!',
              '- 🔐 The encrypted version cannot be read by anyone until 2035',
              '- ⭐ **Star this repository** to remember to come back on January 1, 2035!',
              '- 👁️ **Watch this repository** to get notified when it\'s unveiled!',
              '',
              '### 🎯 How to Get Notified in 2035:',
              '1. Click ⭐ **Star** at the top of this page',
              '2. Click 👁️ **Watch** → **All Activity**',
              '3. You\'ll receive an email notification on January 1, 2035!',
              '',
              '---',
              '',
              '**Thank you for participating in The GitHub Time Capsule!** ❤️',
              '',
              '*🕰️ See you on January 1, 2035!*'
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

      - name: ❌ Comment on PR with failure message
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const username = '${{ steps.extract.outputs.username }}';
            const repoUrl = context.payload.repository.html_url;
            const comment = [
              '## ❌ Message Sealing Failed',
              '',
              `**@${username}**, there was an error sealing your message.`,
              '',
              '### Common Issues:',
              `- ❌ Message file not found (check: \`messages/${username}.txt\`)`,
              '- ❌ File is empty',
              '- ❌ Modified files outside \`messages/\` folder',
              '- ❌ Submitted multiple messages in one day',
              '',
              '### 🔧 How to Fix:',
              `1. Make sure your file is named exactly: \`messages/${username}.txt\``,
              '2. Make sure the file contains your message',
              '3. Only modify files in the \`messages/\` folder',
              '4. Wait 24 hours between submissions',
              '',
              `Please check the [workflow logs](${repoUrl}/actions) for details.`,
              '',
              `Need help? Open an [issue](${repoUrl}/issues/new).`
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

      - name: 🚪 Close PR
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              state: 'closed'
            });
            
            console.log('✅ PR closed automatically');
