name: Seal the Capsule

on:
  pull_request:
    types: [opened]
    paths:
      - 'messages/**'  # Only trigger when messages/ folder changes

permissions:
  contents: write
  pull-requests: write

# Prevent concurrent runs for the same PR
concurrency:
  group: seal-${{ github.event.pull_request.number }}
  cancel-in-progress: false

jobs:
  seal-message:
    runs-on: ubuntu-latest
    
    steps:
      - name: 🔍 Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: "Security: Validate PR changes"
        id: validate
        run: |
          echo "Checking what files were changed..."
          
          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Count changes outside messages/
          DANGEROUS_CHANGES=$(echo "$CHANGED_FILES" | grep -v "^messages/" | grep -v "^$" || true)
          
          if [ ! -z "$DANGEROUS_CHANGES" ]; then
            echo "❌ SECURITY: PR attempts to modify files outside messages/ folder!"
            echo "Blocked files:"
            echo "$DANGEROUS_CHANGES"
            echo ""
            echo "⚠️ Only files in messages/ folder are allowed."
            exit 1
          fi
          
          # Check for multiple message files (spam detection)
          MESSAGE_COUNT=$(echo "$CHANGED_FILES" | grep "^messages/.*\.txt$" | wc -l)
          if [ "$MESSAGE_COUNT" -gt 1 ]; then
            echo "❌ SECURITY: PR contains multiple message files!"
            echo "Only 1 message per user is allowed."
            exit 1
          fi
          
          # Check file ownership - users can only modify their own file
          echo ""
          echo "🔍 Validating file ownership..."
          USERNAME="${{ github.event.pull_request.user.login }}"
          MESSAGE_FILES=$(echo "$CHANGED_FILES" | grep "^messages/.*\.txt$" || true)
          
          if [ ! -z "$MESSAGE_FILES" ]; then
            while IFS= read -r file; do
              if [ ! -z "$file" ]; then
                # Extract filename without path and extension
                FILENAME=$(basename "$file" .txt)
                
                # Skip README and EXAMPLE-MESSAGE (anyone can edit these)
                if [ "$FILENAME" = "README" ] || [ "$FILENAME" = "EXAMPLE-MESSAGE" ]; then
                  echo "ℹ️ Skipping validation for: $file (public file)"
                  continue
                fi
                
                # Check if filename matches PR author username
                if [ "$FILENAME" != "$USERNAME" ]; then
                  echo "❌ SECURITY: You can only modify YOUR OWN message file!"
                  echo ""
                  echo "Your username: @$USERNAME"
                  echo "Expected file: messages/${USERNAME}.txt"
                  echo "Attempted file: $file (belongs to @$FILENAME)"
                  echo ""
                  echo "⚠️ Each user can ONLY create/edit: messages/[YourUsername].txt"
                  echo "❌ You CANNOT modify other users' files!"
                  exit 1
                fi
                
                echo "✅ File ownership valid: $file belongs to @$USERNAME"
              fi
            done <<< "$MESSAGE_FILES"
          fi
          
          echo "✅ Security check passed"

      - name: 🔍 Find new message file
        id: find-file
        run: |
          # Get the username from the PR author
          USERNAME="${{ github.event.pull_request.user.login }}"
          MESSAGE_FILE="messages/${USERNAME}.txt"
          
          echo "Looking for message file: $MESSAGE_FILE"
          
          if [ -f "$MESSAGE_FILE" ]; then
            echo "✅ Found message file: $MESSAGE_FILE"
            echo "message_file=$MESSAGE_FILE" >> $GITHUB_OUTPUT
            echo "username=$USERNAME" >> $GITHUB_OUTPUT
          else
            echo "❌ Expected message file not found: $MESSAGE_FILE"
            echo "Please create a file named messages/${USERNAME}.txt with your message."
            echo ""
            echo "📝 Instructions:"
            echo "1. File must be in messages/ folder"
            echo "2. File must be named: ${USERNAME}.txt (your GitHub username)"
            echo "3. File must contain your message text"
            exit 1
          fi


      - name: "Check for duplicate message and set sealed file name"
        id: set-sealed-file
        run: |
          USERNAME="${{ steps.find-file.outputs.username }}"
          OWNER="ThanhNguyxn"
          BASE_FILE="sealed/${USERNAME}.txt.gpg"
          SEALED_FILE="$BASE_FILE"
          
          git fetch origin main
          if [ "$USERNAME" = "$OWNER" ]; then
            # Owner is allowed unlimited messages, always use next available name
            i=1
            while git ls-tree origin/main "sealed/${USERNAME}*.txt.gpg" | grep -q "$SEALED_FILE"; do
              i=$((i+1))
              SEALED_FILE="sealed/${USERNAME} ($i).txt.gpg"
            done
            echo "Owner detected. Using file: $SEALED_FILE"
          else
            # For normal users, allow multiple messages with auto-incremented names
            i=1
            while git ls-tree origin/main "sealed/${USERNAME}*.txt.gpg" | grep -q "$SEALED_FILE"; do
              i=$((i+1))
              SEALED_FILE="sealed/${USERNAME} ($i).txt.gpg"
            done
            echo "Using file: $SEALED_FILE"
          fi
          echo "sealed_file=$SEALED_FILE" >> $GITHUB_OUTPUT
          echo "✅ Sealed file name set: $SEALED_FILE"

      - name: "Verify message content"
        run: |
          MESSAGE_FILE="${{ steps.find-file.outputs.message_file }}"
          
          if [ ! -s "$MESSAGE_FILE" ]; then
            echo "❌ Message file is empty. Please add your message to the future!"
            exit 1
          fi
          
          FILE_SIZE=$(wc -c < "$MESSAGE_FILE")
          echo "📊 Message size: $FILE_SIZE bytes"
          
          if [ $FILE_SIZE -gt 1048576 ]; then
            echo "❌ Message is too large (>1MB). Please keep your message concise."
            exit 1
          fi
          
          # Check for suspicious content (basic spam detection)
          if grep -qi "http://" "$MESSAGE_FILE" || grep -qi "https://" "$MESSAGE_FILE"; then
            URL_COUNT=$(grep -oi "http" "$MESSAGE_FILE" | wc -l)
            if [ "$URL_COUNT" -gt 3 ]; then
              echo "⚠️ WARNING: Message contains many URLs ($URL_COUNT)"
              echo "This might be spam. Review carefully."
            fi
          fi
          
          echo "✅ Message content validated"

      - name: 🔐 Setup GPG
        run: |
          # Import the public key from secrets
          echo "${{ secrets.GPG_PUBLIC_KEY }}" | gpg --import
          
          # Verify the key was imported
          gpg --list-keys

      - name: 🔒 Encrypt the message
        id: encrypt
        run: |
          MESSAGE_FILE="${{ steps.find-file.outputs.message_file }}"
          USERNAME="${{ steps.find-file.outputs.username }}"
          ENCRYPTED_FILE="sealed/${USERNAME}.txt.gpg"
          
          # Create sealed directory if it doesn't exist
          mkdir -p sealed
          
          # Encrypt the message file
          # Using the key ID or email from the imported public key
          # Add --trust-model always to avoid interactive prompts
          gpg --trust-model always --encrypt --recipient time-capsule-2035 \
              --output "$ENCRYPTED_FILE" "$MESSAGE_FILE"
          
          if [ -f "$ENCRYPTED_FILE" ]; then
            echo "✅ Message encrypted successfully!"
            echo "encrypted_file=$ENCRYPTED_FILE" >> $GITHUB_OUTPUT
            
            ENCRYPTED_SIZE=$(wc -c < "$ENCRYPTED_FILE")
            echo "🔒 Encrypted size: $ENCRYPTED_SIZE bytes"
          else
            echo "❌ Encryption failed!"
            exit 1
          fi

      - name: "Save encrypted file temporarily"
        run: |
          USERNAME="${{ steps.find-file.outputs.username }}"
          # Move encrypted file to temp location
          cp "sealed/${USERNAME}.txt.gpg" "/tmp/${USERNAME}.txt.gpg"
          echo "Saved encrypted file to /tmp/${USERNAME}.txt.gpg"

      - name: "Checkout main branch"
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 📦 Commit encrypted message to main
        run: |
          # Configure git
          git config user.name "Time Capsule Bot"
          git config user.email "time-capsule-bot@users.noreply.github.com"
          
          USERNAME="${{ steps.find-file.outputs.username }}"
          ENCRYPTED_FILE="sealed/${USERNAME}.txt.gpg"
          
          # Create sealed directory in main branch
          mkdir -p sealed
          
          # Copy encrypted file from temp location
          cp "/tmp/${USERNAME}.txt.gpg" "$ENCRYPTED_FILE"
          
          # Add and commit
          git add "$ENCRYPTED_FILE"
          git commit -m "🔒 Seal message from user @${{ github.actor }}"
          git push origin main

      - name: 📊 Update statistics
        run: |
          # Count total sealed messages
          TOTAL_MESSAGES=$(ls -1 sealed/*.gpg 2>/dev/null | wc -l)
          echo "📈 Total messages sealed: $TOTAL_MESSAGES"
          
          # This could be extended to update a stats file or README badge

      - name: 🎉 Close Pull Request
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          USERNAME="${{ steps.find-file.outputs.username }}"
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          
          # Create success message
          cat > comment.md << 'EOF'
          ## 🔒 Message Sealed Successfully!
          
          Thank you! Your message has been encrypted and sealed in the time capsule.
          
          **What happened:**
          - ✅ Message encrypted with GPG
          - ✅ Encrypted file committed to main branch
          - ✅ Original message destroyed (branch deleted)
          
          **Unveiling:** January 1, 2035
          
          See you in the future! 🕰️✨
          EOF
          
          # Comment and close PR
          gh pr comment $PR_NUMBER --body-file comment.md
          gh pr close $PR_NUMBER --comment "🔐 Time capsule sealed. This PR is now closed."
          
          # Delete the branch to destroy original message
          echo "🗑️ Deleting branch '$BRANCH_NAME' to destroy original message..."
          git push origin --delete "$BRANCH_NAME" || echo "⚠️ Branch already deleted or protected"

      - name: ✅ Sealing Complete
        run: |
          echo "╔════════════════════════════════════════╗"
          echo "║   🔒 TIME CAPSULE SEALED 🔒           ║"
          echo "╚════════════════════════════════════════╝"
          echo ""
          echo "Message from @${{ steps.find-file.outputs.username }} has been sealed."
          echo "Unlock Date: January 1, 2035"
          echo ""
          echo "The message sleeps, waiting for its time..."

      - name: ❌ Handle Failure
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          USERNAME="${{ github.event.pull_request.user.login }}"
          
          # Create error message
          cat > error-comment.md << 'EOF'
          ## ❌ Sealing Failed
          
          Unfortunately, we couldn't seal your message. This PR will remain open for review.
          
          **Common issues:**
          - ❌ File name doesn't match your username
          - ❌ File is empty or too large (>1MB)
          - ❌ You already have a sealed message
          - ❌ PR modifies files outside `messages/` folder
          - ❌ PR contains multiple message files
          
          **How to fix:**
          1. Check the workflow logs above for specific error
          2. Fix the issue in your branch
          3. Push changes (will trigger new check)
          
          **Need help?** Open an issue or check [FOR-DEVELOPERS.md](../FOR-DEVELOPERS.md)
          EOF
          
          # Comment on PR
          gh pr comment $PR_NUMBER --body-file error-comment.md || echo "Failed to comment"
          
          echo "❌ Workflow failed - PR left open for manual review"

