name: Seal the Capsule

on:
  pull_request:
    types: [opened]

permissions:
  contents: write
  pull-requests: write

jobs:
  seal-message:
    runs-on: ubuntu-latest
    
    steps:
      - name: üîç Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: üîç Find new message file
        id: find-file
        run: |
          # Get the username from the PR author
          USERNAME="${{ github.event.pull_request.user.login }}"
          MESSAGE_FILE="messages/${USERNAME}.txt"
          
          echo "Looking for message file: $MESSAGE_FILE"
          
          if [ -f "$MESSAGE_FILE" ]; then
            echo "‚úÖ Found message file: $MESSAGE_FILE"
            echo "message_file=$MESSAGE_FILE" >> $GITHUB_OUTPUT
            echo "username=$USERNAME" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Expected message file not found: $MESSAGE_FILE"
            echo "Please create a file named messages/${USERNAME}.txt with your message."
            exit 1
          fi

      - name: üìù Verify message content
        run: |
          MESSAGE_FILE="${{ steps.find-file.outputs.message_file }}"
          
          if [ ! -s "$MESSAGE_FILE" ]; then
            echo "‚ùå Message file is empty. Please add your message to the future!"
            exit 1
          fi
          
          FILE_SIZE=$(wc -c < "$MESSAGE_FILE")
          echo "üìä Message size: $FILE_SIZE bytes"
          
          if [ $FILE_SIZE -gt 1048576 ]; then
            echo "‚ùå Message is too large (>1MB). Please keep your message concise."
            exit 1
          fi

      - name: üîê Setup GPG
        run: |
          # Import the public key from secrets
          echo "${{ secrets.GPG_PUBLIC_KEY }}" | gpg --import
          
          # Verify the key was imported
          gpg --list-keys

      - name: üîí Encrypt the message
        id: encrypt
        run: |
          MESSAGE_FILE="${{ steps.find-file.outputs.message_file }}"
          USERNAME="${{ steps.find-file.outputs.username }}"
          ENCRYPTED_FILE="sealed/${USERNAME}.txt.gpg"
          
          # Create sealed directory if it doesn't exist
          mkdir -p sealed
          
          # Encrypt the message file
          # Using the key ID or email from the imported public key
          # Add --trust-model always to avoid interactive prompts
          gpg --trust-model always --encrypt --recipient time-capsule-2035 \
              --output "$ENCRYPTED_FILE" "$MESSAGE_FILE"
          
          if [ -f "$ENCRYPTED_FILE" ]; then
            echo "‚úÖ Message encrypted successfully!"
            echo "encrypted_file=$ENCRYPTED_FILE" >> $GITHUB_OUTPUT
            
            ENCRYPTED_SIZE=$(wc -c < "$ENCRYPTED_FILE")
            echo "üîí Encrypted size: $ENCRYPTED_SIZE bytes"
          else
            echo "‚ùå Encryption failed!"
            exit 1
          fi

      - name: ÔøΩ Save encrypted file temporarily
        run: |
          USERNAME="${{ steps.find-file.outputs.username }}"
          # Move encrypted file to temp location
          cp "sealed/${USERNAME}.txt.gpg" "/tmp/${USERNAME}.txt.gpg"
          echo "Saved encrypted file to /tmp/${USERNAME}.txt.gpg"

      - name: ÔøΩüîÑ Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üì¶ Commit encrypted message to main
        run: |
          # Configure git
          git config user.name "Time Capsule Bot"
          git config user.email "time-capsule-bot@users.noreply.github.com"
          
          USERNAME="${{ steps.find-file.outputs.username }}"
          ENCRYPTED_FILE="sealed/${USERNAME}.txt.gpg"
          
          # Create sealed directory in main branch
          mkdir -p sealed
          
          # Copy encrypted file from temp location
          cp "/tmp/${USERNAME}.txt.gpg" "$ENCRYPTED_FILE"
          
          # Add and commit
          git add "$ENCRYPTED_FILE"
          git commit -m "üîí Seal message from user @${{ github.actor }}"
          git push origin main

      - name: üìä Update statistics
        run: |
          # Count total sealed messages
          TOTAL_MESSAGES=$(ls -1 sealed/*.gpg 2>/dev/null | wc -l)
          echo "üìà Total messages sealed: $TOTAL_MESSAGES"
          
          # This could be extended to update a stats file or README badge

      - name: üéâ Close Pull Request
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          USERNAME="${{ steps.find-file.outputs.username }}"
          
          # Create success message
          cat > comment.md << 'EOF'
          ## üîí Message Sealed Successfully!
          
          Thank you! Your message has been encrypted and sealed in the time capsule.
          
          **What happened:**
          - ‚úÖ Message encrypted with GPG
          - ‚úÖ Encrypted file committed to main branch
          - ‚úÖ Original message kept private
          
          **Unveiling:** January 1, 2035
          
          See you in the future! üï∞Ô∏è‚ú®
          EOF
          
          # Comment and close PR
          gh pr comment $PR_NUMBER --body-file comment.md
          gh pr close $PR_NUMBER --comment "üîê Time capsule sealed. This PR is now closed."

      - name: ‚úÖ Sealing Complete
        run: |
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë   üîí TIME CAPSULE SEALED üîí           ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "Message from @${{ steps.find-file.outputs.username }} has been sealed."
          echo "Unlock Date: January 1, 2035"
          echo ""
          echo "The message sleeps, waiting for its time..."
