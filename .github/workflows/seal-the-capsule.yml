name: Seal the Capsule

on:
  pull_request:
    types: [opened]
    paths:
      - 'messages/**'  # Only trigger when messages/ folder changes

permissions:
  contents: write
  pull-requests: write

# Prevent concurrent runs for the same PR
concurrency:
  group: seal-${{ github.event.pull_request.number }}
  cancel-in-progress: false

jobs:
  seal-message:
    runs-on: ubuntu-latest
    
    steps:
      - name: üîç Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: ÔøΩÔ∏è Security: Validate PR changes
        id: validate
        run: |
          echo "ÔøΩüîç Checking what files were changed..."
          
          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Count changes outside messages/
          DANGEROUS_CHANGES=$(echo "$CHANGED_FILES" | grep -v "^messages/" | grep -v "^$" || true)
          
          if [ ! -z "$DANGEROUS_CHANGES" ]; then
            echo "‚ùå SECURITY: PR attempts to modify files outside messages/ folder!"
            echo "Blocked files:"
            echo "$DANGEROUS_CHANGES"
            echo ""
            echo "‚ö†Ô∏è Only files in messages/ folder are allowed."
            exit 1
          fi
          
          # Check for multiple message files (spam detection)
          MESSAGE_COUNT=$(echo "$CHANGED_FILES" | grep "^messages/.*\.txt$" | wc -l)
          if [ "$MESSAGE_COUNT" -gt 1 ]; then
            echo "‚ùå SECURITY: PR contains multiple message files!"
            echo "Only 1 message per user is allowed."
            exit 1
          fi
          
          echo "‚úÖ Security check passed"

      - name: üîç Find new message file
        id: find-file
        run: |
          # Get the username from the PR author
          USERNAME="${{ github.event.pull_request.user.login }}"
          MESSAGE_FILE="messages/${USERNAME}.txt"
          
          echo "Looking for message file: $MESSAGE_FILE"
          
          if [ -f "$MESSAGE_FILE" ]; then
            echo "‚úÖ Found message file: $MESSAGE_FILE"
            echo "message_file=$MESSAGE_FILE" >> $GITHUB_OUTPUT
            echo "username=$USERNAME" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Expected message file not found: $MESSAGE_FILE"
            echo "Please create a file named messages/${USERNAME}.txt with your message."
            echo ""
            echo "üìù Instructions:"
            echo "1. File must be in messages/ folder"
            echo "2. File must be named: ${USERNAME}.txt (your GitHub username)"
            echo "3. File must contain your message text"
            exit 1
          fi

      - name: ÔøΩ Check for duplicate message
        run: |
          USERNAME="${{ steps.find-file.outputs.username }}"
          SEALED_FILE="sealed/${USERNAME}.txt.gpg"
          
          # Check if user already has a sealed message
          git fetch origin main
          if git ls-tree origin/main "$SEALED_FILE" | grep -q "$SEALED_FILE"; then
            echo "‚ùå You already have a sealed message!"
            echo "File: $SEALED_FILE"
            echo ""
            echo "Each user can only seal ONE message."
            echo "Your message is already locked until 2035."
            exit 1
          fi
          
          echo "‚úÖ No duplicate found - proceeding with sealing"

      - name: ÔøΩüìù Verify message content
        run: |
          MESSAGE_FILE="${{ steps.find-file.outputs.message_file }}"
          
          if [ ! -s "$MESSAGE_FILE" ]; then
            echo "‚ùå Message file is empty. Please add your message to the future!"
            exit 1
          fi
          
          FILE_SIZE=$(wc -c < "$MESSAGE_FILE")
          echo "üìä Message size: $FILE_SIZE bytes"
          
          if [ $FILE_SIZE -gt 1048576 ]; then
            echo "‚ùå Message is too large (>1MB). Please keep your message concise."
            exit 1
          fi
          
          # Check for suspicious content (basic spam detection)
          if grep -qi "http://" "$MESSAGE_FILE" || grep -qi "https://" "$MESSAGE_FILE"; then
            URL_COUNT=$(grep -oi "http" "$MESSAGE_FILE" | wc -l)
            if [ "$URL_COUNT" -gt 3 ]; then
              echo "‚ö†Ô∏è WARNING: Message contains many URLs ($URL_COUNT)"
              echo "This might be spam. Review carefully."
            fi
          fi
          
          echo "‚úÖ Message content validated"

      - name: üîê Setup GPG
        run: |
          # Import the public key from secrets
          echo "${{ secrets.GPG_PUBLIC_KEY }}" | gpg --import
          
          # Verify the key was imported
          gpg --list-keys

      - name: üîí Encrypt the message
        id: encrypt
        run: |
          MESSAGE_FILE="${{ steps.find-file.outputs.message_file }}"
          USERNAME="${{ steps.find-file.outputs.username }}"
          ENCRYPTED_FILE="sealed/${USERNAME}.txt.gpg"
          
          # Create sealed directory if it doesn't exist
          mkdir -p sealed
          
          # Encrypt the message file
          # Using the key ID or email from the imported public key
          # Add --trust-model always to avoid interactive prompts
          gpg --trust-model always --encrypt --recipient time-capsule-2035 \
              --output "$ENCRYPTED_FILE" "$MESSAGE_FILE"
          
          if [ -f "$ENCRYPTED_FILE" ]; then
            echo "‚úÖ Message encrypted successfully!"
            echo "encrypted_file=$ENCRYPTED_FILE" >> $GITHUB_OUTPUT
            
            ENCRYPTED_SIZE=$(wc -c < "$ENCRYPTED_FILE")
            echo "üîí Encrypted size: $ENCRYPTED_SIZE bytes"
          else
            echo "‚ùå Encryption failed!"
            exit 1
          fi

      - name: ÔøΩ Save encrypted file temporarily
        run: |
          USERNAME="${{ steps.find-file.outputs.username }}"
          # Move encrypted file to temp location
          cp "sealed/${USERNAME}.txt.gpg" "/tmp/${USERNAME}.txt.gpg"
          echo "Saved encrypted file to /tmp/${USERNAME}.txt.gpg"

      - name: ÔøΩüîÑ Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üì¶ Commit encrypted message to main
        run: |
          # Configure git
          git config user.name "Time Capsule Bot"
          git config user.email "time-capsule-bot@users.noreply.github.com"
          
          USERNAME="${{ steps.find-file.outputs.username }}"
          ENCRYPTED_FILE="sealed/${USERNAME}.txt.gpg"
          
          # Create sealed directory in main branch
          mkdir -p sealed
          
          # Copy encrypted file from temp location
          cp "/tmp/${USERNAME}.txt.gpg" "$ENCRYPTED_FILE"
          
          # Add and commit
          git add "$ENCRYPTED_FILE"
          git commit -m "üîí Seal message from user @${{ github.actor }}"
          git push origin main

      - name: üìä Update statistics
        run: |
          # Count total sealed messages
          TOTAL_MESSAGES=$(ls -1 sealed/*.gpg 2>/dev/null | wc -l)
          echo "üìà Total messages sealed: $TOTAL_MESSAGES"
          
          # This could be extended to update a stats file or README badge

      - name: üéâ Close Pull Request
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          USERNAME="${{ steps.find-file.outputs.username }}"
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          
          # Create success message
          cat > comment.md << 'EOF'
          ## üîí Message Sealed Successfully!
          
          Thank you! Your message has been encrypted and sealed in the time capsule.
          
          **What happened:**
          - ‚úÖ Message encrypted with GPG
          - ‚úÖ Encrypted file committed to main branch
          - ‚úÖ Original message destroyed (branch deleted)
          
          **Unveiling:** January 1, 2035
          
          See you in the future! üï∞Ô∏è‚ú®
          EOF
          
          # Comment and close PR
          gh pr comment $PR_NUMBER --body-file comment.md
          gh pr close $PR_NUMBER --comment "üîê Time capsule sealed. This PR is now closed."
          
          # Delete the branch to destroy original message
          echo "üóëÔ∏è Deleting branch '$BRANCH_NAME' to destroy original message..."
          git push origin --delete "$BRANCH_NAME" || echo "‚ö†Ô∏è Branch already deleted or protected"

      - name: ‚úÖ Sealing Complete
        run: |
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë   üîí TIME CAPSULE SEALED üîí           ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "Message from @${{ steps.find-file.outputs.username }} has been sealed."
          echo "Unlock Date: January 1, 2035"
          echo ""
          echo "The message sleeps, waiting for its time..."

      - name: ‚ùå Handle Failure
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          USERNAME="${{ github.event.pull_request.user.login }}"
          
          # Create error message
          cat > error-comment.md << 'EOF'
          ## ‚ùå Sealing Failed
          
          Unfortunately, we couldn't seal your message. This PR will remain open for review.
          
          **Common issues:**
          - ‚ùå File name doesn't match your username
          - ‚ùå File is empty or too large (>1MB)
          - ‚ùå You already have a sealed message
          - ‚ùå PR modifies files outside `messages/` folder
          - ‚ùå PR contains multiple message files
          
          **How to fix:**
          1. Check the workflow logs above for specific error
          2. Fix the issue in your branch
          3. Push changes (will trigger new check)
          
          **Need help?** Open an issue or check [FOR-DEVELOPERS.md](../FOR-DEVELOPERS.md)
          EOF
          
          # Comment on PR
          gh pr comment $PR_NUMBER --body-file error-comment.md || echo "Failed to comment"
          
          echo "‚ùå Workflow failed - PR left open for manual review"
