name: 🔒 Seal Message

on:
  # For fork PRs (external contributors)
  pull_request_target:
    types: [opened]
    branches:
      - main
  # For same-repo PRs (repo owner can't fork their own repo)
  pull_request:
    types: [opened]
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  seal-message:
    runs-on: ubuntu-latest
    
    steps:
      - name: 🔍 Checkout branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.ref }}
          fetch-depth: 0

      - name: 📝 Extract username
        id: extract
        run: |
          USERNAME="${{ github.event.pull_request.user.login }}"
          echo "username=$USERNAME" >> $GITHUB_OUTPUT
          echo "📋 Processing message from: @$USERNAME"

      - name: "🔒 Security: Validate PR changes"
        id: validate
        run: |
          echo "🔍 Checking what files were changed..."
          
          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Count changes outside messages/ folder
          DANGEROUS_CHANGES=$(echo "$CHANGED_FILES" | grep -v "^messages/" | grep -v "^$" || true)

          if [ ! -z "$DANGEROUS_CHANGES" ]; then
            echo "❌ SECURITY: PR attempts to modify files outside messages/ folder!"
            echo "Blocked files:"
            echo "$DANGEROUS_CHANGES"
            echo ""
            echo "⚠️ Only files in messages/ folder are allowed."
            exit 1
          fi

          echo "✅ Security check passed - only messages/ folder modified"

      - name: "⏰ Rate Limit: 1 message per day (UTC)"
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          REPO_OWNER="${{ github.repository_owner }}"
          
          # Allow repository owner to bypass rate limiting (for testing)
          if [ "$USERNAME" = "$REPO_OWNER" ]; then
            echo "✅ Repository owner ($USERNAME) - rate limit bypassed for testing"
            exit 0
          fi
          
          # Check if user has already submitted today (UTC)
          TODAY_UTC=$(date -u +%Y-%m-%d)
          echo "📅 Today (UTC): $TODAY_UTC"
          
          if [ -d "sealed/${USERNAME}" ]; then
            LATEST_FILE=$(ls -t sealed/${USERNAME}/*.gpg 2>/dev/null | head -1)
            if [ ! -z "$LATEST_FILE" ]; then
              # Get file modification date in UTC
              FILE_DATE=$(date -u -r "$LATEST_FILE" +%Y-%m-%d 2>/dev/null || date -u -j -f %s $(stat -f %m "$LATEST_FILE") +%Y-%m-%d 2>/dev/null)
              
              echo "⏰ Last submission date (UTC): $FILE_DATE"
              
              # Check if file was created today (same UTC date)
              if [ "$FILE_DATE" = "$TODAY_UTC" ]; then
                echo ""
                echo "❌ Rate limit exceeded!"
                echo "📅 You already submitted a message today (UTC): $FILE_DATE"
                echo "⏰ Rate limit resets at 00:00 UTC (same as statistics update)"
                echo "💡 You can submit one message per day (UTC timezone)"
                echo ""
                echo "🕐 Current time (UTC): $(date -u +%H:%M:%S)"
                echo "⏳ Next submission available: $(date -u -d 'tomorrow' +%Y-%m-%d) 00:00:00 UTC"
                exit 1
              else
                echo "✅ Last submission was on $FILE_DATE (different day)"
              fi
            fi
          fi
          
          echo "✅ Rate limit check passed - submission allowed for today"

      - name: ✅ Validate message file
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          MESSAGE_FILE="messages/${USERNAME}.txt"
          
          if [ ! -f "$MESSAGE_FILE" ]; then
            echo "❌ Error: $MESSAGE_FILE not found"
            echo "Please create a file named exactly: messages/${USERNAME}.txt"
            exit 1
          fi
          
          # Check if file is not empty
          if [ ! -s "$MESSAGE_FILE" ]; then
            echo "❌ Error: $MESSAGE_FILE is empty"
            exit 1
          fi
          
          echo "✅ Message file found: $MESSAGE_FILE"
          echo "📏 Message size: $(wc -c < "$MESSAGE_FILE") bytes"

      - name: 🔐 Setup GPG
        run: |
          echo "📦 Installing GPG..."
          sudo apt-get update
          sudo apt-get install -y gnupg
          gpg --version

      - name: 🔑 Import GPG public key
        env:
          GPG_PUBLIC_KEY: ${{ secrets.GPG_PUBLIC_KEY }}
        run: |
          if [ -z "$GPG_PUBLIC_KEY" ]; then
            echo "❌ Error: GPG_PUBLIC_KEY secret not configured!"
            echo "Please add GPG_PUBLIC_KEY to repository secrets."
            exit 1
          fi
          
          echo "🔑 Importing GPG public key..."
          echo "$GPG_PUBLIC_KEY" | gpg --import
          
          echo "📋 Listing imported keys:"
          gpg --list-keys

      - name: 🔓 Deobfuscate message (if from web interface)
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          MESSAGE_FILE="messages/${USERNAME}.txt"
          
          # Check if message is obfuscated (base64 encoded with XOR)
          # Web submissions are obfuscated, manual submissions are plain text
          if base64 -d "$MESSAGE_FILE" >/dev/null 2>&1; then
            echo "🔄 Detected obfuscated message from web interface"
            echo "🔓 Deobfuscating..."
            
            # Create Node.js script to deobfuscate
            cat > /tmp/deobfuscate.js << 'EOF'
const fs = require('fs');
const obfuscated = fs.readFileSync(process.argv[1], 'utf8').trim();
try {
  // Decode from base64 and XOR back
  const buffer = Buffer.from(obfuscated, 'base64');
  const deobfuscated = Buffer.from(
    buffer.map((byte, index) => byte ^ (index % 256))
  );
  process.stdout.write(deobfuscated);
} catch (e) {
  // If deobfuscation fails, assume it's plain text
  fs.copyFileSync(process.argv[1], process.argv[2]);
  process.exit(0);
}
EOF
            
            # Deobfuscate the message
            node /tmp/deobfuscate.js "$MESSAGE_FILE" > "${MESSAGE_FILE}.tmp"
            mv "${MESSAGE_FILE}.tmp" "$MESSAGE_FILE"
            
            echo "✅ Message deobfuscated successfully"
          else
            echo "📝 Plain text message detected (manual submission)"
          fi

      - name: 🔒 Encrypt message
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          MESSAGE_FILE="messages/${USERNAME}.txt"
          
          # Create sealed directory structure
          mkdir -p "sealed/${USERNAME}"
          
          # Generate unique filename with timestamp
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          ENCRYPTED_FILE="sealed/${USERNAME}/${USERNAME}-${TIMESTAMP}.gpg"
          
          echo "🔐 Encrypting message..."
          echo "📄 Input: $MESSAGE_FILE"
          echo "🔒 Output: $ENCRYPTED_FILE"
          
          # Encrypt the message
          gpg --encrypt \
              --recipient "time-capsule-2035" \
              --armor \
              --trust-model always \
              --output "$ENCRYPTED_FILE" \
              "$MESSAGE_FILE"
          
          if [ ! -f "$ENCRYPTED_FILE" ]; then
            echo "❌ Encryption failed!"
            exit 1
          fi
          
          echo "✅ Message encrypted successfully!"
          echo "📊 Encrypted file size: $(wc -c < "$ENCRYPTED_FILE") bytes"
          ls -lh "$ENCRYPTED_FILE"
          
          # Save filename for later steps
          echo "encrypted_file=$ENCRYPTED_FILE" >> $GITHUB_ENV

      - name: 💾 Save encrypted file temporarily
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          
          # Copy entire sealed folder to /tmp to preserve across checkout
          cp -r sealed /tmp/sealed-backup
          echo "✅ Saved encrypted files to /tmp/sealed-backup"

      - name: 🔄 Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: 📦 Restore encrypted files
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          
          # Ensure sealed directory exists in main
          mkdir -p sealed
          
          # Restore the encrypted files
          if [ -d "/tmp/sealed-backup/${USERNAME}" ]; then
            mkdir -p "sealed/${USERNAME}"
            cp -r /tmp/sealed-backup/${USERNAME}/* "sealed/${USERNAME}/"
            echo "✅ Restored encrypted files to sealed/${USERNAME}/"
            ls -lh "sealed/${USERNAME}/"
          else
            echo "❌ Failed to restore encrypted files!"
            exit 1
          fi

      - name: ✍️ Commit encrypted message to main
        run: |
          USERNAME="${{ steps.extract.outputs.username }}"
          
          # Configure Git
          git config user.name "Time Capsule Bot"
          git config user.email "bot@github-time-capsule.local"
          
          # Add encrypted files
          git add sealed/${USERNAME}/
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "⚠️ No changes to commit"
          else
            git commit -m "🔒 Sealed message from @${USERNAME}" \
                       -m "Message encrypted and sealed until January 1, 2035." \
                       -m "" \
                       -m "- Encrypted with GPG (AES-256)" \
                       -m "- Stored in: sealed/${USERNAME}/" \
                       -m "- Will be automatically decrypted on Jan 1, 2035"
            
            echo "📤 Pushing to main branch..."
            git push origin main
            echo "✅ Successfully committed and pushed encrypted message!"
          fi

      - name: 🎉 Comment on PR with success message
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            console.log('Attempting to comment on PR...');
            console.log('PR number:', context.issue.number);
            const username = '${{ steps.extract.outputs.username }}';
            const comment = [
              '## 🎉 Your Message Has Been Sealed!',
              '',
              `**@${username}**, your time capsule message has been successfully encrypted and sealed!`,
              '',
              '### ✅ What Just Happened:',
              '- ✅ Your message was encrypted with **AES-256-GCM** encryption',
              `- ✅ Saved to: \`sealed/${username}/\``,
              '- ✅ Committed to the main branch',
              '- ✅ This PR will be closed automatically',
              '',
              '### 🔒 What Happens Next:',
              '- 🔐 Your message is now **locked until January 1, 2035**',
              '- ⏰ On that date, it will be **automatically decrypted**',
              '- 🎉 You and everyone else can read it then!',
              '',
              '### 📌 Important Notes:',
              '- 💾 Keep a copy of your original message in your fork if you want!',
              '- 🔐 The encrypted version cannot be read by anyone until 2035',
              '- ⭐ **Star this repository** to remember to come back on January 1, 2035!',
              '- 👁️ **Watch this repository** to get notified when it\'s unveiled!',
              '',
              '### 🎯 How to Get Notified in 2035:',
              '1. Click ⭐ **Star** at the top of this page',
              '2. Click 👁️ **Watch** → **All Activity**',
              '3. You\'ll receive an email notification on January 1, 2035!',
              '',
              '---',
              '',
              '**Thank you for participating in The GitHub Time Capsule!** ❤️',
              '',
              '*🕰️ See you on January 1, 2035!*'
            ].join('\n');

            const result = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
            console.log('✅ Comment posted successfully!');
            console.log('Comment ID:', result.data.id);

      - name: ❌ Comment on PR with failure message
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            console.log('Attempting to post failure comment...');
            console.log('PR number:', context.issue.number);
            const username = '${{ steps.extract.outputs.username }}';
            const repoUrl = context.payload.repository.html_url;
            const comment = [
              '## ❌ Message Sealing Failed',
              '',
              `**@${username}**, there was an error sealing your message.`,
              '',
              '### Common Issues:',
              `- ❌ Message file not found (check: \`messages/${username}.txt\`)`,
              '- ❌ File is empty',
              '- ❌ Modified files outside \`messages/\` folder',
              '- ❌ Submitted multiple messages in one day',
              '',
              '### 🔧 How to Fix:',
              `1. Make sure your file is named exactly: \`messages/${username}.txt\``,
              '2. Make sure the file contains your message',
              '3. Only modify files in the \`messages/\` folder',
              '4. Wait 24 hours between submissions',
              '',
              `Please check the [workflow logs](${repoUrl}/actions) for details.`,
              '',
              `Need help? Open an [issue](${repoUrl}/issues/new).`
            ].join('\n');

            const result = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
            console.log('✅ Failure comment posted successfully!');
            console.log('Comment ID:', result.data.id);

      - name: 🚪 Close PR
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            // Wait 2 seconds to ensure comment is posted first
            console.log('Waiting 2 seconds before closing PR...');
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            console.log('Closing PR #' + context.issue.number);
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              state: 'closed'
            });
            
            console.log('✅ PR closed automatically');
